import { Injectable, NotFoundException } from '@nestjs/common';import { PrismaService } from '../prisma/prisma.service';import { Prisma, Order, OrderStatus } from '@prisma/client';import { ProductService } from '../product/product.service';@Injectable()export class OrderService {  constructor(    private prisma: PrismaService,    private productService: ProductService,  ) {}  async create(data: Prisma.OrderCreateInput): Promise<Order> {    const order = await this.prisma.order.create({ data });    // Assuming order items are created separately or included in a more complex DTO    return order;  }  async findAll(userId: string): Promise<Order[]> {    return this.prisma.order.findMany({      where: { userId },      include: { orderItems: { include: { product: true } } },      orderBy: { createdAt: 'desc' },    });  }  async findOne(id: string, userId: string): Promise<Order | null> {    return this.prisma.order.findUnique({      where: { id, userId },      include: { orderItems: { include: { product: true } } },    });  }  async update(    id: string,    userId: string,    data: Prisma.OrderUpdateInput,  ): Promise<Order> {    return this.prisma.order.update({ where: { id, userId }, data });  }  async remove(id: string, userId: string): Promise<Order> {    return this.prisma.order.delete({ where: { id, userId } });  }  async createOrderItem(    orderId: string,    productId: string,    quantity: number,  ): Promise<any> {    const product = await this.productService.findOne(productId, null); // Assuming product can be found by ID without user context here    if (!product || product.stock < quantity) {      throw new NotFoundException('Product not found or insufficient stock');    }    const orderItem = await this.prisma.orderItem.create({      data: {        order: { connect: { id: orderId } },        product: { connect: { id: productId } },        quantity,        priceAtOrder: product.price,      },    });    await this.productService.updateStock(productId, quantity); // Decrement stock    return orderItem;  }  async getSalesSummary(userId: string) {    const now = new Date();    const startOfDay = new Date(now.setHours(0, 0, 0, 0));    const startOfWeek = new Date(now.setDate(now.getDate() - now.getDay()));    const startOfMonth = new Date(now.setDate(1));    const totalSalesToday = await this.prisma.order.aggregate({      _sum: { totalAmount: true },      where: {        userId,        createdAt: { gte: startOfDay },        status: { in: [OrderStatus.CONFIRMED, OrderStatus.DELIVERED] },      },    });    const totalSalesWeek = await this.prisma.order.aggregate({      _sum: { totalAmount: true },      where: {        userId,        createdAt: { gte: startOfWeek },        status: { in: [OrderStatus.CONFIRMED, OrderStatus.DELIVERED] },      },    });    const totalSalesMonth = await this.prisma.order.aggregate({      _sum: { totalAmount: true },      where: {        userId,        createdAt: { gte: startOfMonth },        status: { in: [OrderStatus.CONFIRMED, OrderStatus.DELIVERED] },      },    });    const totalOrders = await this.prisma.order.count({ where: { userId } });    const confirmedOrders = await this.prisma.order.count({      where: { userId, status: OrderStatus.CONFIRMED },    });    const deliveredOrders = await this.prisma.order.count({      where: { userId, status: OrderStatus.DELIVERED },    });    const canceledOrders = await this.prisma.order.count({      where: { userId, status: OrderStatus.CANCELED },    });    const conversionRate =      totalOrders > 0      ? ((confirmedOrders + deliveredOrders) / totalOrders) * 100      : 0;    const avgOrderValue =      (totalSalesMonth._sum.totalAmount || 0) /      (confirmedOrders + deliveredOrders > 0        ? confirmedOrders + deliveredOrders        : 1);    const bestSellingProduct = await this.prisma.orderItem.groupBy({      by: ['productId'],      _sum: { quantity: true },      where: {        order: {          userId,          createdAt: { gte: startOfMonth },          status: { in: [OrderStatus.CONFIRMED, OrderStatus.DELIVERED] },        },      },      orderBy: { _sum: { quantity: 'desc' } },      take: 1,    });    let bestSellerName = null;    if (bestSellingProduct.length > 0) {      const product = await this.prisma.product.findUnique({        where: { id: bestSellingProduct[0].productId },      });      bestSellerName = product ? product.name : 'N/A';    }    return {      todaySales: totalSalesToday._sum.totalAmount || 0,      weekSales: totalSalesWeek._sum.totalAmount || 0,      monthSales: totalSalesMonth._sum.totalAmount || 0,      conversionRate: parseFloat(conversionRate.toFixed(2)),      avgOrderValue: parseFloat(avgOrderValue.toFixed(2)),      bestSeller: bestSellerName,      canceledOrders,      recentOrders: await this.prisma.order.findMany({        where: { userId },        orderBy: { createdAt: 'desc' },        take: 3,        include: { orderItems: { include: { product: true } } },      }),    };  }}